{"ast":null,"code":"import React, { useRef } from 'react';\n\n// vector add\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n    value = fallback;\n  }\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    // @ts-ignore\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n  var result = {};\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n      key = _Object$entries$_i[0],\n      resolver = _Object$entries$_i[1];\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n      case false:\n        return ensureVector(0);\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  }\n};\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n      _value2$left = _value2.left,\n      left = _value2$left === void 0 ? -Infinity : _value2$left,\n      _value2$right = _value2.right,\n      right = _value2$right === void 0 ? Infinity : _value2$right,\n      _value2$top = _value2.top,\n      top = _value2$top === void 0 ? -Infinity : _value2$top,\n      _value2$bottom = _value2.bottom,\n      bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n    window.toString = function () {\n      return _window.toString();\n    };\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$passive = _ref.passive,\n      passive = _ref$passive === void 0 ? true : _ref$passive,\n      _ref$capture = _ref.capture,\n      capture = _ref$capture === void 0 ? false : _ref$capture;\n    return {\n      passive: passive,\n      capture: capture\n    };\n  }\n};\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n      distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n      _ref2$angleBounds = _ref2.angleBounds,\n      angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n      filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n      _ref3$lockDirection = _ref3.lockDirection,\n      lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n      _ref3$axis = _ref3.axis,\n      axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps || A[0] + A[1] > 0;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n    return ensureVector(v);\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  }\n});\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n    eventOptions = _ref.eventOptions,\n    window = _ref.window,\n    enabled = _ref.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n    eventOptions = _ref2.eventOptions,\n    window = _ref2.window,\n    enabled = _ref2.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n    eventOptions = _ref3.eventOptions,\n    window = _ref3.window,\n    enabled = _ref3.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n    eventOptions = _ref4.eventOptions,\n    window = _ref4.window,\n    enabled = _ref4.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n    eventOptions = _ref5.eventOptions,\n    window = _ref5.window,\n    enabled = _ref5.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n    eventOptions = _ref6.eventOptions,\n    window = _ref6.window,\n    enabled = _ref6.enabled,\n    rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n  if (actions === void 0) {\n    actions = new Set();\n  }\n  var _config = config,\n    drag = _config.drag,\n    wheel = _config.wheel,\n    move = _config.move,\n    scroll = _config.scroll,\n    pinch = _config.pinch,\n    hover = _config.hover,\n    eventOptions = _config.eventOptions,\n    window = _config.window,\n    domTarget = _config.domTarget,\n    enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    eventOptions: eventOptions,\n    window: window,\n    domTarget: domTarget,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  };\n  var drag = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    _isTap: true,\n    _delayedEvent: false,\n    _pointerId: undefined,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-ignore origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\nvar RecognizersMap = /*#__PURE__*/new Map();\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n    if (args === void 0) {\n      args = [];\n    }\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n      if (ms === void 0) {\n        ms = 140;\n      }\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n          _this.clean();\n        }\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state)); // @ts-ignore\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_this.state._active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n  var _proto = Recognizer.prototype;\n\n  // Convenience method to update the shared state\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */;\n\n  _proto.getMovement = function getMovement(values) {\n    var _this$config = this.config,\n      initial = _this$config.initial,\n      bounds = _this$config.bounds,\n      rubberband = _this$config.rubberband,\n      T = _this$config.threshold;\n    var _this$state = this.state,\n      _bounds = _this$state._bounds,\n      _initial = _this$state._initial,\n      _active = _this$state._active,\n      wasIntentional = _this$state._intentional,\n      lastOffset = _this$state.lastOffset,\n      prevMovement = _this$state.movement;\n    var M = this.getInternalMovement(values, this.state);\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n    var __cachedBounds;\n    var __cachedInitial;\n    if (_intentional[0] !== false && wasIntentional[0] === false) {\n      __cachedInitial = valueFn(initial, this.state);\n      __cachedBounds = valueFn(bounds, this.state);\n      _initial[0] = __cachedInitial[0];\n      _bounds[0] = __cachedBounds[0];\n    }\n    if (_intentional[1] !== false && wasIntentional[1] === false) {\n      var _cachedInitial, _cachedBounds;\n      __cachedInitial = (_cachedInitial = __cachedInitial) != null ? _cachedInitial : valueFn(initial, this.state);\n      __cachedBounds = (_cachedBounds = __cachedBounds) != null ? _cachedBounds : valueFn(bounds, this.state);\n      _initial[1] = __cachedInitial[1];\n      _bounds[1] = __cachedBounds[1];\n    }\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : _initial[0], _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n  return Recognizer;\n}(); //--------------------------------------------\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n    Vy = _ref[1];\n  var Rx = _ref2[0],\n    Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n    X1 = _bounds$[0],\n    X2 = _bounds$[1],\n    _bounds$2 = bounds[1],\n    Y1 = _bounds$2[0],\n    Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state,\n    args = _ref3.args;\n  var timeStamp = event.timeStamp,\n    _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    args: args,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\nfunction getStartGestureState(recognizer, values, event) {\n  var offset = recognizer.state.offset;\n  var startTime = event.timeStamp;\n  return _extends({}, getInitialState()[recognizer.stateKey], {\n    _active: true,\n    values: values,\n    initial: values,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n}\nfunction partial(func, state) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // @ts-ignore\n    return func.call.apply(func, [this, _extends({}, state, {\n      event: event\n    })].concat(args));\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n  this.classes = classes;\n  this.bind = function () {\n    var bindings = {};\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // we also add event bindings for native handlers\n\n    for (var _i = 0, _Object$entries = Object.entries(_this.nativeRefs); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n        event = _Object$entries$_i[0],\n        handler = _Object$entries$_i[1];\n      addBindings(bindings, event, partial(handler, _extends({}, _this.state.shared, {\n        args: args\n      })));\n    }\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n    el = _controller$config.window,\n    eventOptions = _controller$config.eventOptions,\n    windowListeners = controller.windowListeners;\n  if (!el) return;\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n  controller.windowListeners = {};\n}\nfunction clearWindowListeners(_ref, stateKey) {\n  var config = _ref.config,\n    windowListeners = _ref.windowListeners;\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  delete windowListeners[stateKey];\n}\nfunction updateWindowListeners(_ref2, stateKey, listeners) {\n  var config = _ref2.config,\n    windowListeners = _ref2.windowListeners;\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  addListeners(config.window, windowListeners[stateKey] = listeners, config.eventOptions);\n}\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n    domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n      key = _Object$entries2$_i[0],\n      fns = _Object$entries2$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n  addListeners(domTarget, domListeners, eventOptions);\n}\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n  for (var _i3 = 0, _Object$entries3 = Object.entries(bindings); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _Object$entries3[_i3],\n      event = _Object$entries3$_i[0],\n      fns = _Object$entries3$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n  return props;\n}\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n  return array.splice(0, array.length);\n}\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n      eventName = _step2$value[0],\n      eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n      eventName = _step3$value[0],\n      eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n  var classes = resolveClasses(handlers);\n  var controller = React.useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  React.useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = CoordinatesRecognizer.prototype;\n\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n    var _movement$map = _movement.map(Math.abs),\n      absX = _movement$map[0],\n      absY = _movement$map[1];\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n    return state;\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n  return CoordinatesRecognizer;\n}(Recognizer);\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && window.ontouchstart === null;\n}\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var targetTouches = event.targetTouches,\n      changedTouches = event.changedTouches;\n    return targetTouches.length > 0 ? targetTouches : changedTouches;\n  }\n  return null;\n}\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  var shiftKey = event.shiftKey,\n    altKey = event.altKey,\n    metaKey = event.metaKey,\n    ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    touches: touches,\n    down: down,\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n  var _ref = touchEvents ? touchEvents[0] : event,\n    clientX = _ref.clientX,\n    clientY = _ref.clientY;\n  return [clientX, clientY];\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n    scrollX = _event$currentTarget.scrollX,\n    scrollY = _event$currentTarget.scrollY,\n    scrollLeft = _event$currentTarget.scrollLeft,\n    scrollTop = _event$currentTarget.scrollTop;\n  return [scrollX || scrollLeft || 0, scrollY || scrollTop || 0];\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n    deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return [deltaX, deltaY];\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation];\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\nfunction getTwoTouchesEventData(event) {\n  var _e$rotation;\n  var targetTouches = event.targetTouches;\n  var A = targetTouches[0],\n    B = targetTouches[1];\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2;\n  var e = 'nativeEvent' in event ? event.nativeEvent : event;\n  var distance = Math.hypot(dx, dy);\n  var angle = (_e$rotation = e.rotation) != null ? _e$rotation : -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = [distance, angle];\n  var origin = [cx, cy];\n  return {\n    values: values,\n    origin: origin\n  };\n}\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n  function DragRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag';\n    /**\r\n     * TODO add back when setPointerCapture is widely wupported\r\n     * https://caniuse.com/#search=setPointerCapture\r\n     * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\r\n     *   const { currentTarget, pointerId } = event\r\n     *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\r\n     *   this.updateGestureState({ currentTarget, pointerId })\r\n     * }\r\n            * private removePointers = () => {\r\n     *   const { currentTarget, pointerId } = this.state\r\n     *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\r\n     * }\r\n     */\n\n    _this.onDragStart = function (event) {\n      if (!_this.enabled || _this.state._active) return;\n      /**\r\n       * TODO add back when setPointerCapture is widely supported\r\n       * this.setPointers(event as PointerEvent)\r\n       */\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['pointermove', _this.onDragChange], ['pointerup', _this.onDragEnd], ['pointercancel', _this.onDragEnd]]); // We set the state pointerId to the event.pointerId so we can make sure\n      // that we lock the drag to the event initiating the gesture\n\n      _this.updateGestureState({\n        _pointerId: event.pointerId\n      });\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true; // If it's a React SyntheticEvent we need to persist it so that we can use it async\n\n        if ('persist' in event && typeof event.persist === 'function') event.persist();\n        _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n    _this.onDragChange = function (event) {\n      // If the gesture was canceled don't respond to the event.\n      if (_this.state.canceled) return; // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n\n      if (event.pointerId !== _this.state._pointerId) return; // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n          _this.startDrag(event);\n        }\n        return;\n      }\n      var genericEventData = getGenericEventData(event); // If the event doesn't have any button / touches left we should cancel\n      // the gesture. This may happen if the drag release happens outside the browser\n      // window.\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n        return;\n      }\n      _this.updateSharedState(genericEventData);\n      var values = getPointerEventValues(event);\n      var kinematics = _this.getKinematics(values, event);\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var _isTap = _this.state._isTap;\n      var realDistance = calculateDistance(kinematics._movement);\n      if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _isTap: _isTap\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onDragEnd = function (event) {\n      // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n      if (event.pointerId !== _this.state._pointerId) return;\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n      var tap = _this.state._isTap;\n      var _this$state$velocitie = _this.state.velocities,\n        vx = _this$state$velocitie[0],\n        vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n        mx = _this$state$movement[0],\n        my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n        ix = _this$state$_intentio[0],\n        iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n        svx = _this$config$swipeVel[0],\n        svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n        sx = _this$config$swipeDis[0],\n        sy = _this$config$swipeDis[1];\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n      var swipe = [0, 0];\n      if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n      _this.fireGestureHandler(tap === true);\n    };\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n      _this.state._delayedEvent = false; // can't remember if this is useful?\n\n      clearWindowListeners(_this.controller, _this.stateKey); // TODO add back when setPointerCapture is widely wupported\n      // this.removePointers()\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.updateGestureState({\n        canceled: true\n      });\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    _this.onClick = function (event) {\n      if (!_this.state._isTap) event.stopPropagation();\n    };\n    return _this;\n  }\n  var _proto = DragRecognizer.prototype;\n  _proto.startDrag = function startDrag(event) {\n    var values = getPointerEventValues(event);\n    this.updateSharedState(getGenericEventData(event));\n    this.updateGestureState(_extends({}, getStartGestureState(this, values, event), getGenericPayload(this, event, true), {\n      _pointerId: event.pointerId,\n      cancel: this.onCancel\n    }));\n    this.updateGestureState(this.getMovement(values));\n    this.fireGestureHandler();\n  };\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onPointerDown', this.onDragStart);\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n      addBindings(bindings, handler, this.onClick);\n    } // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n  return memoized;\n}\n\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\nfunction equal(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n      return true;\n    }\n    var it;\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n      return true;\n    }\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n    return true;\n  } // true if both NaN, false otherwise  NaN !== NaN  true\n  // eslint-disable-next-line no-self-compare\n\n  return a !== a && b !== b;\n}\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n    throw error;\n  }\n}\n\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = useRef();\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n  var _proto = DistanceAngleRecognizer.prototype;\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n      _values$ = values[1],\n      a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state.movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n    var kinematics = calculateAllKinematics(state.movement, state.delta, dt);\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n  return DistanceAngleRecognizer;\n}(Recognizer);\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n  function PinchRecognizer() {\n    var _this;\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n        touches = _getGenericEventData.touches;\n      return _this.enabled && touches === 2;\n    };\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n        values = _getTwoTouchesEventDa.values,\n        origin = _getTwoTouchesEventDa.origin;\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n        canceled = _this$state.canceled,\n        _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n        values = _getTwoTouchesEventDa2.values,\n        origin = _getTwoTouchesEventDa2.origin; // @ts-ignore\n\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: origin\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values)));\n      _this.fireGestureHandler();\n    };\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.state._active = false;\n      _this.updateGestureState({\n        canceled: true\n      });\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault(); // useless\n\n      var values = getWebkitGestureEventValues(event);\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n        canceled = _this$state2.canceled,\n        _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n      _this.updateSharedState(genericEventData);\n      var values = getWebkitGestureEventValues(event);\n      var kinematics = _this.getKinematics(values, event);\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        origin: [event.clientX, event.clientY]\n      }));\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n        delta_d = _getWheelEventValues[1];\n      var _this$state$values = _this.state.values,\n        prev_d = _this$state$values[0],\n        prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n      _this.setTimeout(_this.onWheelEnd);\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF.values,\n        delta = _this$getWheelValuesF.delta,\n        origin = _this$getWheelValuesF.origin;\n      if (event.cancelable) event.preventDefault();else if (process.env.NODE_ENV === 'development') {\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n      _this.updateSharedState(getGenericEventData(event));\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        initial: _this.state.values,\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n        values = _this$getWheelValuesF2.values,\n        origin = _this$getWheelValuesF2.origin,\n        delta = _this$getWheelValuesF2.delta;\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n      _this.fireGestureHandler();\n    };\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = useRef();\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n  function WheelRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n      _this.setTimeout(_this.onEnd);\n      _this.updateSharedState(getGenericEventData(event));\n      var values = addV(getWheelEventValues(event), _this.state.values);\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n        var movement = _this.getMovement(values);\n        var geometry = calculateAllGeometry(movement.delta);\n        _this.updateGestureState(movement);\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n      _this.fireGestureHandler();\n    };\n    _this.onEnd = function () {\n      var movement = _this.getMovement(_this.state.values);\n      _this.updateGestureState(movement);\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = WheelRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = useRef();\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n  function MoveRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n      _this.setTimeout(_this.onMoveEnd);\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n      var values = getPointerEventValues(event);\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n      _this.updateGestureState(_this.getMovement(values));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n      var values = getPointerEventValues(event);\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      _this.fireGestureHandler();\n    };\n    _this.onMoveEnd = function () {\n      var values = _this.state.values;\n      _this.updateGestureState(_this.getMovement(values));\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n      _this.fireGestureHandler();\n    };\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event);\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          values: values,\n          active: true,\n          hovering: true\n        });\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event);\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        values: values,\n        active: false\n      });\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n    return _this;\n  }\n  var _proto = MoveRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = useRef();\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = useRef();\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n  function ScrollRecognizer() {\n    var _this;\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n      _this.clearTimeout();\n      _this.setTimeout(_this.onEnd);\n      var values = getScrollEventValues(event);\n      _this.updateSharedState(getGenericEventData(event));\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n        var movementDetection = _this.getMovement(values);\n        var geometry = calculateAllGeometry(movementDetection.delta);\n        _this.updateGestureState(movementDetection);\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n      _this.fireGestureHandler();\n    };\n    _this.onEnd = function () {\n      _this.state._active = false;\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n      _this.fireGestureHandler();\n    };\n    return _this;\n  }\n  var _proto = ScrollRecognizer.prototype;\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = useRef();\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var _sortHandlers = sortHandlers(_handlers),\n    handlers = _sortHandlers[0],\n    nativeHandlers = _sortHandlers[1],\n    actions = _sortHandlers[2];\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  return fn;\n}\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","apply","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","minMax","value","min","max","rubberband2","constant","pow","rubberband","dimension","abs","Infinity","rubberbandIfOutOfBounds","position","noop","chainFns","fns","Array","_len","_key","arguments","length","result","_iterator","_createForOfIteratorHelperLoose","_step","done","fn","ensureVector","fallback","undefined","Error","isArray","assignDefault","Object","assign","valueFn","_len2","args","_key2","resolveWith","config","resolvers","_i","_Object$entries","entries","_Object$entries$_i","key","resolver","call","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","_extends","axis","lockDirection","bounds","state","left","_value2$left","right","_value2$right","top","_value2$top","bottom","_value2$bottom","isBrowser","window","document","createElement","InternalGenericOptionsNormalizers","domTarget","_window","_x","toString","eventOptions","_temp","passive","_ref$passive","capture","_ref$capture","InternalDistanceAngleOptionsNormalizers","_value","_ref2","distanceBounds","_ref2$distanceBounds","angleBounds","_ref2$angleBounds","_distanceBounds","D","_angleBounds","A","InternalDragOptionsNormalizers","_k","_ref3","filterTaps","_ref3$filterTaps","_ref3$lockDirection","_ref3$axis","swipeVelocity","swipeDistance","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","_buildMoveConfig","_ref","rest","_objectWithoutPropertiesLoose","opts","move","_buildHoverConfig","hover","_buildDragConfig","drag","_buildPinchConfig","_ref4","pinch","_buildScrollConfig","_ref5","scroll","_buildWheelConfig","_ref6","wheel","buildComplexConfig","actions","Set","_config","mergedConfig","has","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","event","intentional","values","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","xy","vxvy","_isTap","_delayedEvent","_pointerId","tap","swipe","da","vdva","origin","turns","RecognizersMap","Map","Recognizer","controller","debounced","setTimeout","callback","ms","clearTimeout","_this","timeouts","stateKey","concat","fireGestureHandler","forceFlag","clean","prev_active","next_active","ingKey","mapStateValues","newMemo","handler","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","_this$config","T","_this$state","wasIntentional","prevMovement","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","__cachedBounds","__cachedInitial","_cachedInitial","_cachedBounds","_rubberband","computeRubberband","handlers","Vx","Vy","Rx","Ry","X1","_bounds$","X2","Y1","_bounds$2","Y2","getGenericPayload","isStartEvent","type","getStartGestureState","recognizer","partial","func","Controller","classes","bind","bindings","RecognizerClass","addBindings","nativeRefs","updateDomListeners","getPropsListener","effect","getDomTargetFromConfig","removeListeners","takeAll","domListeners","forEach","clearAllWindowListeners","windowListeners","el","_controller$config","clearWindowListeners","updateWindowListeners","listeners","addListeners","_i2","_Object$entries2","_Object$entries2$_i","name","slice","toLowerCase","push","props","captureString","_i3","_Object$entries3","_Object$entries3$_i","fnsArray","array","splice","current","options","_iterator2","_step2","_step2$value","eventName","eventHandler","addEventListener","_iterator3","_step3","_step3$value","removeEventListener","useRecognizers","nativeHandlers","resolveClasses","React","useMemo","useEffect","deprecationNoticeForDomTarget","process","env","NODE_ENV","console","warn","internalHandlers","add","get","CoordinatesRecognizer","_Recognizer","absX","_movement$map","absY","getKinematics","WEBKIT_DISTANCE_SCALE_FACTOR","supportsGestureEvents","GestureEvent","e","supportsTouchEvents","ontouchstart","getTouchEvents","targetTouches","changedTouches","getGenericEventData","touchEvents","getPointerEventValues","clientX","clientY","getScrollEventValues","currentTarget","scrollX","_event$currentTarget","scrollY","scrollLeft","scrollTop","getWheelEventValues","deltaX","deltaY","getWebkitGestureEventValues","scale","rotation","getTwoTouchesEventData","B","dx","dy","cx","cy","nativeEvent","angle","_e$rotation","atan2","PI","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","DragRecognizer","_CoordinatesRecognize","_inheritsLoose","onDragStart","onDragChange","onDragEnd","pointerId","persist","startDrag","_assertThisInitialized","genericEventData","kinematics","genericPayload","realDistance","vx","_this$state$velocitie","vy","mx","_this$state$movement","my","ix","_this$state$_intentio","iy","svx","_this$config$swipeVel","svy","sx","_this$config$swipeDis","sy","endState","prototype","onCancel","requestAnimationFrame","onClick","stopPropagation","_proto","addBindings$1","memoizeOne","resultFn","isEqual","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","equal","a","b","constructor","keys","it","size","next","RegExp","source","flags","valueOf","hasOwnProperty","Element","$$typeof","error","message","match","useDrag","set","buildDragConfig","useRef","DistanceAngleRecognizer","prev_a","d","_values$","delta_a","next_turns","PinchRecognizer","_DistanceAngleRecogni","pinchShouldStart","_getGenericEventData","onPinchStart","_getTwoTouchesEventDa","onPinchChange","_getTwoTouchesEventDa2","onPinchEnd","onGestureStart","preventDefault","onGestureChange","_this$state2","onGestureEnd","wheelShouldRun","getWheelValuesFromEvent","delta_d","_getWheelEventValues","prev_d","_this$state$values","onWheel","onWheelEnd","onWheelStart","onWheelChange","_this$getWheelValuesF","cancelable","_this$getWheelValuesF2","usePinch","buildPinchConfig","WheelRecognizer","handleEvent","onEnd","geometry","useWheel","buildWheelConfig","MoveRecognizer","onMove","onMoveEnd","onMoveStart","onMoveChange","onPointerEnter","onPointerLeave","useMove","buildMoveConfig","useHover","buildHoverConfig","ScrollRecognizer","movementDetection","useScroll","buildScrollConfig","RE_NOT_NATIVE","sortHandlers","_native","handle","test","lastMatch","useGesture","_handlers","_sortHandlers","includeStartEndHandlers","onHover","handlerKey","startKey","endKey"],"sources":["B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\math.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\rubberband.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\utils.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\resolveOptionsWith.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\config.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\buildConfig.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\state.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\Recognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\Controller.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useRecognizers.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\CoordinatesRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\event.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\DragRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\memoize-one.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\utils\\react-fast-compare.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useDrag.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\DistanceAngleRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\PinchRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\usePinch.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\WheelRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useWheel.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\MoveRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useMove.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useHover.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\recognizers\\ScrollRecognizer.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useScroll.ts","B:\\dev\\3DModelViewer\\frontend\\node_modules\\react-use-gesture\\src\\hooks\\useGesture.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 60\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }: any) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  threshold(\n    this: any,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }: any\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps || A[0] + A[1] > 0\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({ eventOptions, window, domTarget, enabled })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    _isTap: true,\n    _delayedEvent: false,\n    _pointerId: undefined,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle>({\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-ignore origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {}\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { initial, bounds, rubberband, threshold: T } = this.config\n\n    const { _bounds, _initial, _active, _intentional: wasIntentional, lastOffset, movement: prevMovement } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    let __cachedBounds\n    let __cachedInitial\n\n    if (_intentional[0] !== false && wasIntentional[0] === false) {\n      __cachedInitial = valueFn(initial, this.state)\n      __cachedBounds = valueFn(bounds, this.state)\n      _initial[0] = __cachedInitial[0]\n      _bounds[0] = __cachedBounds[0]\n    }\n    if (_intentional[1] !== false && wasIntentional[1] === false) {\n      __cachedInitial = __cachedInitial ?? valueFn(initial, this.state)\n      __cachedBounds = __cachedBounds ?? valueFn(bounds, this.state)\n      _initial[1] = __cachedInitial[1]\n      _bounds[1] = __cachedBounds[1]\n    }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : _initial[0],\n      _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1],\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!this.state._active) this.clean()\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state, args }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, args, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  recognizer: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T]\n) {\n  const offset = recognizer.state.offset\n  const startTime = event.timeStamp\n\n  return {\n    ...getInitialState()[recognizer.stateKey],\n    _active: true,\n    values,\n    initial: values,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\nfunction partial(func: Fn, state: any) {\n  return function (event: any, ...args: any) {\n    // @ts-ignore\n    return func.call(this, { ...state, event }, ...args)\n  }\n}\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // we also add event bindings for native handlers\n    for (let [event, handler] of Object.entries(this.nativeRefs))\n      addBindings(bindings, event, partial(handler, { ...this.state.shared, args }))\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners({ config, windowListeners }: Controller, stateKey: StateKey) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = []\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), config.eventOptions)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && window.ontouchstart === null\n}\n\nfunction getTouchEvents(event: DomEvents) {\n  if ('touches' in event) {\n    const { targetTouches, changedTouches } = event\n    return targetTouches.length > 0 ? targetTouches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { touches, down, buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent\n): Vector2 {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return [clientX, clientY]\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent): Vector2 {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return [deltaX, deltaY]\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Vector2 {\n  return [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent | TouchEvent) {\n  const { targetTouches } = event\n  const A = targetTouches[0],\n    B = targetTouches[1]\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n\n  const values: Vector2 = [distance, angle]\n  const origin: Vector2 = [cx, cy]\n\n  return { values, origin }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  /**\n   * TODO add back when setPointerCapture is widely wupported\n   * https://caniuse.com/#search=setPointerCapture\n   * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n   *   const { currentTarget, pointerId } = event\n   *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\n   *   this.updateGestureState({ currentTarget, pointerId })\n   * }\n\n   * private removePointers = () => {\n   *   const { currentTarget, pointerId } = this.state\n   *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n   * }\n   */\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled || this.state._active) return\n\n    /**\n     * TODO add back when setPointerCapture is widely supported\n     * this.setPointers(event as PointerEvent)\n     */\n\n    updateWindowListeners(this.controller, this.stateKey, [\n      ['pointermove', this.onDragChange],\n      ['pointerup', this.onDragEnd],\n      ['pointercancel', this.onDragEnd],\n    ])\n\n    // We set the state pointerId to the event.pointerId so we can make sure\n    // that we lock the drag to the event initiating the gesture\n    this.updateGestureState({ _pointerId: event.pointerId })\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      // If it's a React SyntheticEvent we need to persist it so that we can use it async\n      if ('persist' in event && typeof event.persist === 'function') event.persist()\n      this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent) {\n    const values = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: event.pointerId,\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    // If the gesture was canceled don't respond to the event.\n    if (this.state.canceled) return\n\n    // If the event pointerId doesn't match the initiating pointerId\n    // don't respond to the event.\n    if (event.pointerId !== this.state._pointerId) return\n\n    // If the gesture isn't active then respond to the event only if\n    // it's been delayed via the `delay` option, in which case start\n    // the gesture immediately.\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    // If the event doesn't have any button / touches left we should cancel\n    // the gesture. This may happen if the drag release happens outside the browser\n    // window.\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n    const values = getPointerEventValues(event)\n\n    const kinematics = this.getKinematics(values, event)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    let { _isTap } = this.state\n    const realDistance = calculateDistance(kinematics._movement!)\n    if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _isTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    // If the event pointerId doesn't match the initiating pointerId\n    // don't respond to the event.\n    if (event.pointerId !== this.state._pointerId) return\n\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const tap = this.state._isTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false // can't remember if this is useful?\n    clearWindowListeners(this.controller, this.stateKey)\n    // TODO add back when setPointerCapture is widely wupported\n    // this.removePointers()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._isTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onPointerDown', this.onDragStart)\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n\n    // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise  NaN !== NaN  true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state.movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const kinematics = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n  supportsTouchEvents,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  private pinchShouldStart = (event: React.TouchEvent | TouchEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      // TODO remove after type update\n      // @ts-ignore\n      ...getStartGestureState(this, values, event),\n      // @ts-ignore\n      ...getGenericPayload(this, event, true),\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    // @ts-ignore\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      // @ts-ignore\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      // @ts-ignore\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.state._active = false\n    this.updateGestureState({ canceled: true })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault() // useless\n\n    const values = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const values = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      initial: this.state.values,\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = useRef<any>()\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.current(config))\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}","import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = useRef<any>()\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event)\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = useRef<any>()\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.current(config))\n}\n","import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = useRef<any>()\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n\n\n","import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = useRef<any>()\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.current(config))\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}